library(ncdf4)
library(maptools)
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/NENY_NHDCatchment.shp", proj4string=CRS(proj4.NHD))
NCDF <- nc_open('C:/KPONEIL/temporary/dayl_1980.nc4')    #netcdf
print(NCDF)
variables <- "dayl"
catchmentShapefile <- catchments
start1 = c(1,1)
latcount <- c(NCDF$var$lat$varsize[1], NCDF$var$lat$varsize[2])
loncount <- c(NCDF$var$lon$varsize[1], NCDF$var$lon$varsize[2])
YDcount  <- NCDF$var$yearday$varsize
# Read in variables
lat = ncvar_get ( nc=NCDF, varid="lat", start = start1, count = latcount )
lon = ncvar_get ( nc=NCDF, varid="lon", start = start1, count = loncount )
dOY = ncvar_get ( nc=NCDF, varid="yearday",             start = 1,      count = YDcount  )
# Correction for Daymet doy which starts at 0.
dOY <- dOY + 1
# Join coordinate lists
masterCoords <- cbind( as.vector(lon), as.vector(lat))
colnames(masterCoords) <- c("Longitude", "Latitude")
masterCoordsMatrix <- masterCoords
masterCoords <- as.data.frame(masterCoords)
fids <- catchments@data$FEATUREID
i = 1
print(paste0(round(i/length(fids), digits = 3)*100, '% done.'))
catchmentShape <- as(catchmentShapefile[catchmentShapefile$FEATUREID %in% fids[i],], "SpatialPolygons")
# Determine which points fall inside catchment
a <- SpatialPoints(masterCoords, proj4string=CRS(proj4.NHD))
inside <- as.data.frame(a[!is.na(over(a, catchmentShape)),])
inside
EXT <- extent(catchmentShape)
library(raster)
EXT <- extent(catchmentShape)
EXT
EXT@xmin
tempCoords <- masterCoords[which(masterCoords$Latitude >= EXT@ymin & masterCoords$Latitude <= EXT@ymax & masterCoords$Longitude >= EXT@xmin & masterCoords$Longitude <= EXT@xmax),]
tempCoords
b <- SpatialPoints(masterCoords, proj4string=CRS(proj4.NHD))
inside <- as.data.frame(a[!is.na(over(a, catchmentShape)),])
inside <- as.data.frame(b[!is.na(over(b, catchmentShape)),])
inside
inside <- as.data.frame(a[!is.na(over(a, catchmentShape)),])
names(inside) <- c('Longitude', 'Latitude')
inside
for ( m in 1:nrow(inside) ){
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
start2 = c(as.numeric(position[,1]), as.numeric(position[,2]), 1)
varcount = c(1, 1, NCDF$var$yearday$varsize)
var = ncvar_get ( nc=NCDF, varid= paste0(variables[j]), start = start2, count = varcount )
nc_close(NCDF)
if (m == 1) {tempVar <- data.frame(dOY, var)} else(tempVar <- cbind(tempVar, var))
}
j = 1
for ( m in 1:nrow(inside) ){
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
start2 = c(as.numeric(position[,1]), as.numeric(position[,2]), 1)
varcount = c(1, 1, NCDF$var$yearday$varsize)
var = ncvar_get ( nc=NCDF, varid= paste0(variables[j]), start = start2, count = varcount )
nc_close(NCDF)
if (m == 1) {tempVar <- data.frame(dOY, var)} else(tempVar <- cbind(tempVar, var))
}
print(NCDF)
NCDF <- nc_open('C:/KPONEIL/temporary/dayl_1980.nc4')    #netcdf
print(NCDF)
m
for ( m in 1:nrow(inside) ){
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
start2 = c(as.numeric(position[,1]), as.numeric(position[,2]), 1)
varcount = c(1, 1, NCDF$var$yearday$varsize)
var = ncvar_get ( nc=NCDF, varid= paste0(variables[j]), start = start2, count = varcount )
if (m == 1) {tempVar <- data.frame(dOY, var)} else(tempVar <- cbind(tempVar, var))
}
tempVar
tempVar[,-c('dOY')]
tempVar[,"var"]
tempVar[,c("var")]
ifelse( ncol(tempVar) > 2, R <- rowMeans(tempVar[,-1], na.rm = TRUE, dims = 1),  R <- tempVar[,-1] )
head(R)
tempVar <- data.frame(tempVar$dOY, R)
head(tempVar)
variable = "dayl"
tempVar <- data.frame(dOY = tempVar$dOY, paste(variable) = R)
for ( m in 1:nrow(inside) ){
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
start2 = c(as.numeric(position[,1]), as.numeric(position[,2]), 1)
varcount = c(1, 1, NCDF$var$yearday$varsize)
var = ncvar_get ( nc=NCDF, varid= paste0(variables[j]), start = start2, count = varcount )
if (m == 1) {tempVar <- data.frame(dOY, var)} else(tempVar <- cbind(tempVar, var))
}
ifelse( ncol(tempVar) > 2, R <- rowMeans(tempVar[,-1], na.rm = TRUE, dims = 1),  R <- tempVar[,-1] )
varMeans <- data.frame(dOY = tempVar$dOY, paste(variable) = R)
variable
paste(variable)
R
varMeans <- data.frame(dOY = tempVar$dOY)
head(varMeans)
varMeans[,paste(fid)] <- R
varMeans[,paste(fid[i])] <- R
varMeans[,paste(fids[i])] <- R
head(varMeans)
CRS(catchments)
variable <- 'tmin'
year <- '2012'
address <- paste0('ftp://daac.ornl.gov/data/daymet/Daymet_mosaics/data/', variable, '_', year, '.nc4')
beg <- proc.time()[3]
download.file(url = address, destfile = paste0('C:/Users/koneil/Downloads', variable,'_', year, '.nc') )
end <- proc.time()[3]
runTime <- (end - beg)/3600
14/32
12000*5
/3600
60000/3600
install.packages("C:/Users/koneil/Downloads/khufkens-daymetr-5185bb94b4a5.zip", repos = NULL)
install.packages("C:/Users/koneil/Downloads/khufkens-daymetr-5185bb94b4a5/DaymetR.tar.gz", repos = NULL, type = "source")
library(DaymetR)
get.daymet(site="Oak Ridge National Laboratories",lat=36.0133,lon=-84.2625,start_yr=1980,end_yr=2010,internal=TRUE)
?DaymetR
get.Daymet(site="Oak Ridge National Laboratories",lat=36.0133,lon=-84.2625,start_yr=1980,end_yr=2010,internal=TRUE)
ls()
Oak Ridge National Laboratories
"Oak Ridge National Laboratories"
?get.Daymet
get.Daymet(site="test1",lat=36.0133,lon=-84.2625,start_yr=1980,end_yr=2010,internal=TRUE)
test1
head(test1)
str(test1)
library(maptools)
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
centroids <- coordinates(catchments)
head(centroids)
centroids <- data.frame(catchments@data$FEATUREID, coordinates(catchments))
head(centroids)
centroids <- data.frame(FEATUREID = catchments@data$FEATUREID, coordinates(catchments))
head(centroids)
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[,2], lon=centroids[,1], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[,3], lon=centroids[,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
warnings
warnings()
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
runTime <- (end - beg)/3600
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
library(maptools)
library(DaymetR)
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
centroids <- data.frame(FEATUREID = catchments@data$FEATUREID, coordinates(catchments))
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
runTime <- (end - beg)/3600
runTime
runTime*60
6.7115*120000/53
15195/60
253.25/24
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste(centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
warnings
warnings()
runTime <- (end - beg)/3600
runTime
5849340
str("5849340")
str(5849340)
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste('F_', centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
rm(list= ls())
library(maptools)
library(DaymetR)
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
centroids <- data.frame(FEATUREID = catchments@data$FEATUREID, coordinates(catchments))
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste('F_', centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
runTime <- (end - beg)/3600
str(F_5849340)
str(F_ 5849340)
rm(list = ls())
library(maptools)
library(DaymetR)
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
centroids <- data.frame(FEATUREID = catchments@data$FEATUREID, coordinates(catchments))
i = 1
get.Daymet(site=paste0('F_', centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
str(F_5849344)
F_5849344$lattitude
F_5849344$data
length(which(is.na(F_5849344$data)))
dim(F_5849344$data)
head(F_5849344$data)
str(F_5849344$data)
runTime
beg <- proc.time()[3]
for( i in 1:100){
get.Daymet(site=paste0('F_', centroids$FEATUREID[i]), lat=centroids[i,3], lon=centroids[i,2], start_yr=1980, end_yr=2013,internal=TRUE)
print(i)
}
end <- proc.time()[3]
runTime <- (end - beg)/3600
runTime
.193*120000/100
231.6/24
?getDaymet
?get.Daymet
library(dplyr)
setwd('C:/KPONEIL/GitHub/personal/dataProcessing/daymet')
db <- dbConnect(SQLite(), "test1")
library(RSQLite)
db <- dbConnect(SQLite(), "test1")
db
d <- dbGetQuery(db, "SELECT FROM testing")
testing
library(dplyr)
cmon <- tbl(db(), "testing")
cmon <- tbl(db, "testing")
?dbReadTable-methods
x1 <- src_sqlite("test1", create = F)
x1
cmon <- tbl(x1, "testing")
cmon
testing <- data.frame(variable = "dayl", year = 1980, testOut)
library(ncdf4)
NCDF <- nc_open('C:/KPONEIL/temporary/dayl_1980.nc4')    #netcdf
print(NCDF)
NCDF$attirbute
NCDF$attirbutes
NCDF$attributes
NCDF$attribute
NCDF$attr
ncatt_get( NCDF, varid = global, attname=start_year, verbose=FALSE )
ncatt_get( NCDF, attname=start_year, verbose=FALSE )
ncatt_get( NCDF, varid == 0 , attname=start_year, verbose=FALSE )
ncatt_get( NCDF, varid==0, attname=start_year, verbose=FALSE )
ncatt_get( NCDF, varid = "global", attname=start_year, verbose=FALSE )
ncatt_get( NCDF, varid = "global")
ncatt_get( NCDF, varid = "global attributes")
print(NCDF)
NCDF$var
for( i in 1:length(NCDF$var) ){
print(NCDF$var[[h]]$name)
}
for( h in 1:length(NCDF$var) ){
print(NCDF$var[[h]]$name)
}
ncatt_get( NCDF, varid = "yearday")
ncatt_get( NCDF, varid = "tim_bnds")
ncatt_get( NCDF, varid = "time_bnds")
ncatt_get( NCDF, varid = "time_bnds", attname="start_year")
ncatt_get( NCDF, varid = "dayl", attname="start_year")
ncatt_get( NCDF, varid = "yearday", attname="start_year")
print(NCDF)
ncatt_get( NCDF, varid = 0, attname="start_year")
ncatt_get( NCDF, varid = 0, attname="start_year")$value
YEAR <- ncatt_get( NCDF, varid = 0, attname="start_year")$value
YEAR
library(maptools)
library(raster)
proj4.NHD  <- "+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs"
# Catchments shapefile
catchments <- readShapePoly ( "C:/KPONEIL/gis/nhdPlusV2/stateCatchments/MA_Catchment.shp", proj4string=CRS(proj4.NHD))
NCDF <- nc_open('C:/KPONEIL/temporary/dayl_1980.nc4')    #netcdf
spatialAverageDaymet2 <- function(NetCDF, variable, catchmentShapefile, projectionString){
require(raster)
require(ncdf4)
# Index the portion of the NetCDF covered by the shapefile
# --------------------------------------------------------
# Read in variables
lat = ncvar_get ( nc=NetCDF, varid="lat", start = start1, count = c(NetCDF$var$lat$varsize[1], NetCDF$var$lat$varsize[2]) )
lon = ncvar_get ( nc=NetCDF, varid="lon", start = start1, count = c(NetCDF$var$lon$varsize[1], NetCDF$var$lon$varsize[2]) )
# Get the extent of the shapefile
EXT <- extent(catchments)
# Positions in the array of coordinates within the shapefile extent
matInd <- which(lat >= EXT@ymin & lat <= EXT@ymax & lon >= EXT@xmin & lon <= EXT@xmax, arr.ind = T)
# Corners of the box in the array
minRow <- min(matInd[,1])
maxRow <- max(matInd[,1])
minCol <- min(matInd[,2])
maxCol <- max(matInd[,2])
# Number of rows and columns
countx = maxRow - minRow + 1
county = maxCol - minCol + 1
# Remove the full NetCDF lat/lon coordinates. These will be replaced with the
rm(lat,lon)
# Read the variables for the subsetted netcdf
var = ncvar_get( nc = NetCDF, varid="dayl",    start = c(minRow, minCol, 1), count = c(countx,county,365) )
lat = ncvar_get( nc = NetCDF, varid="lat",     start = c(minRow, minCol),    count = c(countx,county) )
lon = ncvar_get( nc = NetCDF, varid="lon",     start = c(minRow, minCol),    count = c(countx,county) )
dOY = ncvar_get( nc = NetCDF, varid="yearday", start = 1,                    count = NetCDF$var$yearday$varsize  )
# Correction for Daymet doy which starts at 0.
dOY <- dOY + 1
# Get the year for output
YEAR <- ncatt_get( NCDF, varid = 0, attname="start_year")$value
# Index and replace missval
# -------------------------
for( h in 1:length(NCDF$var) ){
if ( NCDF$var[[h]]$name == variable ) {varIndex <- h}
}
missingValue <- NCDF$var[[varIndex]]$missval
# Replace
var <- replace(var, var == missingValue, NA)
# Prep the points for indexing
# ----------------------------
# Join coordinate lists
masterCoords <- cbind( as.vector(lon), as.vector(lat))
colnames(masterCoords) <- c("Longitude", "Latitude")
masterCoords       <- as.data.frame(masterCoords)
masterCoordsMatrix <- as.matrix(masterCoords)
masterCoordSpPts   <- SpatialPoints(masterCoords, proj4string = projectionString)
# Generate list of catchment centroids
centroids <- data.frame(catchmentShapefile@data$FEATUREID, coordinates(catchmentShapefile) )
names(centroids) <- c('FEATUREID', 'LON', 'LAT')
# Overlay points on catchment shapefile
overPoints <- over(masterCoordSpPts, catchmentShapefile)
# Generate a list of the points and which
pointsInside <- overPoints[which(!is.na(overPoints$FEATUREID)),]
# Add the coordinates of the points inside the catchments
ptsInCoords <- as.data.frame(masterCoordSpPts[as.numeric(row.names(pointsInside))])
pointsInside$Longitude <- ptsInCoords$x
pointsInside$Latitude  <- ptsInCoords$y
# List of FeatureIDs to average over
fids <- catchmentShapefile@data$FEATUREID
# Replace with means
varMeans <- data.frame(dOY = dOY, year = YEAR, variable = variable)
for ( i in seq_along(fids) ){
print(paste0(round(i/length(fids), digits = 3)*100, '% done.    ', i))
inside <- pointsInside[which(pointsInside$FEATUREID == fids[i]),c('Longitude', 'Latitude')]
#If no point falls within the catchment, find the nearest one:
#-------------------------------------------------------------
if(nrow(inside) == 0 ){
tempLat <- centroids$LAT[centroids$FEATUREID == fids[i]]
tempLon <- centroids$LON[centroids$FEATUREID == fids[i]]
distances <- spDistsN1(masterCoordsMatrix, c(tempLon, tempLat), longlat = TRUE)
minDist <- min(distances)
distpos <- which(distances == minDist)[1]
nearLon  <- masterCoords[distpos, 1]
nearLat  <- masterCoords[distpos, 2]
inside[1,1] <- nearLon
inside[1,2] <- nearLat
}
# Index data for points within the watershed
# ------------------------------------------
for ( m in 1:nrow(inside) ){
# Find th position in the array of the variable
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
# Pull those values
indVar <- var[as.numeric(position[,1]), as.numeric(position[,2]), 1:365]
# Join them in an array
if (m == 1) {tempVar <- data.frame(dOY, indVar)} else(tempVar <- cbind(tempVar, indVar))
}
# Which columns to average
toBeAvg <- which(names(tempVar) == 'indVar')
# Take the average across all points
ifelse( length(toBeAvg) > 1, R <- rowMeans(tempVar[,toBeAvg], na.rm = TRUE, dims = 1),  R <- tempVar[,2] )
# Add means to data.frame
varMeans[,paste(fids[i])] <- R
}
# Return the records
return(varMeans)
}
beg <- proc.time()[3]
testOut <- spatialAverageDaymet2(NetCDF = NCDF, variable = "dayl", catchmentShapefile = catchments, projectionString = CRS(proj4.NHD))
end <- proc.time()[3]
runTime <- (end - beg)/3600
print(NCDF)
spatialAverageDaymet2 <- function(NetCDF, variable, catchmentShapefile, projectionString){
require(raster)
require(ncdf4)
# Index the portion of the NetCDF covered by the shapefile
# --------------------------------------------------------
# Read in variables
lat = ncvar_get ( nc=NetCDF, varid="lat", start = c(1,1), count = c(NetCDF$var$lat$varsize[1], NetCDF$var$lat$varsize[2]) )
lon = ncvar_get ( nc=NetCDF, varid="lon", start = c(1,1), count = c(NetCDF$var$lon$varsize[1], NetCDF$var$lon$varsize[2]) )
# Get the extent of the shapefile
EXT <- extent(catchments)
# Positions in the array of coordinates within the shapefile extent
matInd <- which(lat >= EXT@ymin & lat <= EXT@ymax & lon >= EXT@xmin & lon <= EXT@xmax, arr.ind = T)
# Corners of the box in the array
minRow <- min(matInd[,1])
maxRow <- max(matInd[,1])
minCol <- min(matInd[,2])
maxCol <- max(matInd[,2])
# Number of rows and columns
countx = maxRow - minRow + 1
county = maxCol - minCol + 1
# Remove the full NetCDF lat/lon coordinates. These will be replaced with the
rm(lat,lon)
# Read the variables for the subsetted netcdf
var = ncvar_get( nc = NetCDF, varid="dayl",    start = c(minRow, minCol, 1), count = c(countx,county,365) )
lat = ncvar_get( nc = NetCDF, varid="lat",     start = c(minRow, minCol),    count = c(countx,county) )
lon = ncvar_get( nc = NetCDF, varid="lon",     start = c(minRow, minCol),    count = c(countx,county) )
dOY = ncvar_get( nc = NetCDF, varid="yearday", start = 1,                    count = NetCDF$var$yearday$varsize  )
# Correction for Daymet doy which starts at 0.
dOY <- dOY + 1
# Get the year for output
YEAR <- ncatt_get( NCDF, varid = 0, attname="start_year")$value
# Index and replace missval
# -------------------------
for( h in 1:length(NCDF$var) ){
if ( NCDF$var[[h]]$name == variable ) {varIndex <- h}
}
missingValue <- NCDF$var[[varIndex]]$missval
# Replace
var <- replace(var, var == missingValue, NA)
# Prep the points for indexing
# ----------------------------
# Join coordinate lists
masterCoords <- cbind( as.vector(lon), as.vector(lat))
colnames(masterCoords) <- c("Longitude", "Latitude")
masterCoords       <- as.data.frame(masterCoords)
masterCoordsMatrix <- as.matrix(masterCoords)
masterCoordSpPts   <- SpatialPoints(masterCoords, proj4string = projectionString)
# Generate list of catchment centroids
centroids <- data.frame(catchmentShapefile@data$FEATUREID, coordinates(catchmentShapefile) )
names(centroids) <- c('FEATUREID', 'LON', 'LAT')
# Overlay points on catchment shapefile
overPoints <- over(masterCoordSpPts, catchmentShapefile)
# Generate a list of the points and which
pointsInside <- overPoints[which(!is.na(overPoints$FEATUREID)),]
# Add the coordinates of the points inside the catchments
ptsInCoords <- as.data.frame(masterCoordSpPts[as.numeric(row.names(pointsInside))])
pointsInside$Longitude <- ptsInCoords$x
pointsInside$Latitude  <- ptsInCoords$y
# List of FeatureIDs to average over
fids <- catchmentShapefile@data$FEATUREID
# Replace with means
varMeans <- data.frame(dOY = dOY, year = YEAR, variable = variable)
for ( i in seq_along(fids) ){
print(paste0(round(i/length(fids), digits = 3)*100, '% done.    ', i))
inside <- pointsInside[which(pointsInside$FEATUREID == fids[i]),c('Longitude', 'Latitude')]
#If no point falls within the catchment, find the nearest one:
#-------------------------------------------------------------
if(nrow(inside) == 0 ){
tempLat <- centroids$LAT[centroids$FEATUREID == fids[i]]
tempLon <- centroids$LON[centroids$FEATUREID == fids[i]]
distances <- spDistsN1(masterCoordsMatrix, c(tempLon, tempLat), longlat = TRUE)
minDist <- min(distances)
distpos <- which(distances == minDist)[1]
nearLon  <- masterCoords[distpos, 1]
nearLat  <- masterCoords[distpos, 2]
inside[1,1] <- nearLon
inside[1,2] <- nearLat
}
# Index data for points within the watershed
# ------------------------------------------
for ( m in 1:nrow(inside) ){
# Find th position in the array of the variable
position <- which(lon == inside$Longitude[m] & lat == inside$Latitude[m], arr.in = TRUE)
# Pull those values
indVar <- var[as.numeric(position[,1]), as.numeric(position[,2]), 1:365]
# Join them in an array
if (m == 1) {tempVar <- data.frame(dOY, indVar)} else(tempVar <- cbind(tempVar, indVar))
}
# Which columns to average
toBeAvg <- which(names(tempVar) == 'indVar')
# Take the average across all points
ifelse( length(toBeAvg) > 1, R <- rowMeans(tempVar[,toBeAvg], na.rm = TRUE, dims = 1),  R <- tempVar[,2] )
# Add means to data.frame
varMeans[,paste(fids[i])] <- R
}
# Return the records
return(varMeans)
}
beg <- proc.time()[3]
testOut <- spatialAverageDaymet2(NetCDF = NCDF, variable = "dayl", catchmentShapefile = catchments, projectionString = CRS(proj4.NHD))
end <- proc.time()[3]
runTime <- (end - beg)/3600
head(testOut)
testOut[1:10,1:10]
library(RSQLite)
library(dplyr)
setwd('C:/KPONEIL/GitHub/personal/dataProcessing/daymet')
my_db <- src_sqlite("dayTest2", create = T)
db <- dbConnect(SQLite(), "dayTest2")
dbWriteTable(db, "data", testOut, append = FALSE)
